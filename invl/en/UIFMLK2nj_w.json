{
  "video_id": "UIFMLK2nj_w",
  "title": "Second Order Optimization - The Math of Intelligence #2",
  "json": [
    {
      "index": 1,
      "start_time": 17020.0,
      "end_time": 20200.0,
      "text": "Hello World it’s Siraj and let's talk about optimization"
    },
    {
      "index": 2,
      "start_time": 24200.0,
      "end_time": 33600.0,
      "text": "There are 1000s of languages spoken across the world, each one unique in its ability to represents concepts and convey ideas."
    },
    {
      "index": 3,
      "start_time": 33600.0,
      "end_time": 40560.0,
      "text": "No one person is fluent in all of them, but there is one language that is shared by all humans, regardless of where you come from; Mathematics."
    },
    {
      "index": 4,
      "start_time": 40560.0,
      "end_time": 51100.0,
      "text": "No matter your culture or your age, you possess the ability to understand this language of numbers that connects us all across continents and time."
    },
    {
      "index": 5,
      "start_time": 51100.0,
      "end_time": 55000.0,
      "text": "Like all languages, fluency requires practice."
    },
    {
      "index": 6,
      "start_time": 55000.0,
      "end_time": 64460.0,
      "text": "But unlike any other language, the more fluent you become in math the more unstoppable you’ll be in anything you want to do in life."
    },
    {
      "index": 7,
      "start_time": 64459.99999999999,
      "end_time": 74740.0,
      "text": "Math is happening all around us, to a degree most people don’t realize. We can think of everything as a set of variables, as metrics."
    },
    {
      "index": 8,
      "start_time": 74740.0,
      "end_time": 79320.0,
      "text": "and there exists relations between all of these variables."
    },
    {
      "index": 9,
      "start_time": 79320.0,
      "end_time": 86940.0,
      "text": "In math, we call these relations functions. Its our way of representing a set of patterns, a mapping,"
    },
    {
      "index": 10,
      "start_time": 86940.0,
      "end_time": 91260.0,
      "text": "a relationship between many variables."
    },
    {
      "index": 11,
      "start_time": 91260.0,
      "end_time": 104560.0,
      "text": "No matter what machine learning model we use, no matter what dataset we use, the goal of machine learning is to optimize for an objective and by doing so we are approximating a function."
    },
    {
      "index": 12,
      "start_time": 104560.0,
      "end_time": 111660.0,
      "text": "The process of optimization helps us iteratively discover the functions hidden in the depth of data."
    },
    {
      "index": 13,
      "start_time": 111660.0,
      "end_time": 118660.0,
      "text": "Last week we talked about a popular optimization technique called Skit 1 gradient descent."
    },
    {
      "index": 14,
      "start_time": 118660.0,
      "end_time": 128020.0,
      "text": "This can be broken down into a 5 step process. First we define some machine learning model with a set of initial weight values,"
    },
    {
      "index": 15,
      "start_time": 128020.00000000001,
      "end_time": 133940.0,
      "text": "these act as the the coefficients of the function that the model represents."
    },
    {
      "index": 16,
      "start_time": 133940.0,
      "end_time": 147380.0,
      "text": "The mapping between input data and output predictions. These values are naive, we have no idea what they should actually be, we’re trying to discover the optimal ones."
    },
    {
      "index": 17,
      "start_time": 147380.0,
      "end_time": 158400.0,
      "text": "We’ll define an error function and when we plot the graph of the relationship between all the possible error values and all the possible weight values for our function,"
    },
    {
      "index": 18,
      "start_time": 158400.0,
      "end_time": 172220.0,
      "text": "we’ll see that there exists a valley, the minima. We’ll use our error to help us compute the partial derivative with respect to each weight value we have and this gives us our gradient."
    },
    {
      "index": 19,
      "start_time": 172220.0,
      "end_time": 181240.0,
      "text": "The gradient represents the change in the error when the weights are changed by a very small value from their original value."
    },
    {
      "index": 20,
      "start_time": 181240.0,
      "end_time": 189480.0,
      "text": "We use the gradient to update the values of our weights in a direction such that the error is minimized,"
    },
    {
      "index": 21,
      "start_time": 189480.0,
      "end_time": 199220.0,
      "text": "teratively coming closer and closer to the minima of the function. We step our solution in the negative direction of the gradient repeatedly."
    },
    {
      "index": 22,
      "start_time": 199220.0,
      "end_time": 208580.0,
      "text": "When we reach it, we have learned the optimal weight values for our model, where our gradient is equal to zero."
    },
    {
      "index": 23,
      "start_time": 208580.0,
      "end_time": 214420.0,
      "text": "Our model will then be able to make predictions for input data it’s never seen before."
    },
    {
      "index": 24,
      "start_time": 214420.0,
      "end_time": 219840.0,
      "text": "Most optimization problems can be solved using gradient descent and its variants."
    },
    {
      "index": 25,
      "start_time": 219840.0,
      "end_time": 231480.0,
      "text": "They all fall into a category called first order optimization methods. We call them first order because they only require us to compute the first derivative."
    },
    {
      "index": 26,
      "start_time": 231480.0,
      "end_time": 242200.0,
      "text": "But theres another class of techniques that aren’t as widely used called second order optimization methods that require us to compute the second derivative."
    },
    {
      "index": 27,
      "start_time": 242200.0,
      "end_time": 257340.0,
      "text": "The first derivative tells us if the function is increasing or decreasing at a certain point, and the second derivative tells us if the first derivative is increasing or decreasing, which hints at its curvature."
    },
    {
      "index": 28,
      "start_time": 257339.99999999997,
      "end_time": 270960.0,
      "text": "First order methods provide us with a line that is tangential to a point on an error surface, and second order methods provides us with a quadratic surface that kisses the curvature of the error surface."
    },
    {
      "index": 29,
      "start_time": 270960.0,
      "end_time": 283260.0,
      "text": "Haha Get a room you two The advantage then of second order methods is that they don’t ignore the curvature of the error surface, and in terms of step-wise performance, they are better."
    },
    {
      "index": 30,
      "start_time": 283260.0,
      "end_time": 290740.0,
      "text": "Lets look at a popular second order optimization technique called Newton’s method named after the dude who invented calculus."
    },
    {
      "index": 31,
      "start_time": 290740.0,
      "end_time": 294920.0,
      "text": "Who’s name was…"
    },
    {
      "index": 32,
      "start_time": 294920.0,
      "end_time": 304880.0,
      "text": "There are actually two versions of Newton’s method, the first version is for finding the roots of a polynomial, all those points where it intersects the x-axis."
    },
    {
      "index": 33,
      "start_time": 304880.0,
      "end_time": 313440.0,
      "text": "So if you threw a ball and recorded its trajectory, finding the root of the equation would tell you exactly what time it hits the ground."
    },
    {
      "index": 34,
      "start_time": 313440.0,
      "end_time": 318260.0,
      "text": "The second version is for optimization and its what we use in machine learning."
    },
    {
      "index": 35,
      "start_time": 318260.0,
      "end_time": 324620.0,
      "text": "But lets code the root finding version first to develop some basic intuition."
    },
    {
      "index": 36,
      "start_time": 358300.0,
      "end_time": 374540.0,
      "text": "Lets say we have a function f of x and some initial guessed solution. Newtons method says that we first find the slope of the tangent line at our guess point, then find the point at which the tangent line intersects the x axis."
    },
    {
      "index": 37,
      "start_time": 374540.0,
      "end_time": 379340.0,
      "text": "We’ll use that point to find its projection in the original function."
    },
    {
      "index": 38,
      "start_time": 379340.0,
      "end_time": 385600.0,
      "text": "Then we iterate again from our first step, this time replacing our first point with this one."
    },
    {
      "index": 39,
      "start_time": 385600.0,
      "end_time": 392580.0,
      "text": "We keep iterating and eventually we’ll stop when our current value of x is less than or equal to a threshold."
    },
    {
      "index": 40,
      "start_time": 392580.0,
      "end_time": 400480.0,
      "text": "So thats the root finding version of Newton’s Method, where we’re trying to find where the function equals zero,"
    },
    {
      "index": 41,
      "start_time": 400480.0,
      "end_time": 407080.0,
      "text": "but in the optimization version, we’re trying to find where the derivative of the function equals zero, its minima."
    },
    {
      "index": 42,
      "start_time": 407080.0,
      "end_time": 420600.0,
      "text": "At a high level, given a random starting location, we construct a quadratic approximation to the objective function that matches the first and second derivative values at that point."
    },
    {
      "index": 43,
      "start_time": 420600.0,
      "end_time": 425860.0,
      "text": "And then we minimize that quadratic function instead of the original function."
    },
    {
      "index": 44,
      "start_time": 425860.0,
      "end_time": 434440.0,
      "text": "he minimizer of the quadratic function is used as the starting point in the next step and we repeat this process iteratively."
    },
    {
      "index": 45,
      "start_time": 434440.0,
      "end_time": 441580.0,
      "text": "OK lets go over two cases of Newton’s Method for optimization to learn more, a 1D case and 2D case."
    },
    {
      "index": 46,
      "start_time": 441600.0,
      "end_time": 452900.0,
      "text": "In the first case we’ve got a 1 dimensional function. We can obtain a quadratic approximation at a given point of the function using what’s called a Taylor series expansion,"
    },
    {
      "index": 47,
      "start_time": 452900.0,
      "end_time": 456400.0,
      "text": "neglecting terms of order three or higher."
    },
    {
      "index": 48,
      "start_time": 457760.0,
      "end_time": 468640.0,
      "text": "A Taylor series is a representation of a function as an infinite sum of terms that are calculated from the values of the functions derivatives at a single point."
    },
    {
      "index": 49,
      "start_time": 468660.0,
      "end_time": 485560.0,
      "text": "It was invented by an English mathematician named Brook Taylor. Swift. So we’d take the second order Taylor series for our initial point x, and minimize it by finding the first derivative and second derivative  and equating them to zero."
    },
    {
      "index": 50,
      "start_time": 485560.0,
      "end_time": 490320.0,
      "text": "In order to find the minimum x value, we iterate this process."
    },
    {
      "index": 51,
      "start_time": 490320.0,
      "end_time": 500320.0,
      "text": "In the second case, lets say we’ve got a function of multiple dimensions. We can find the minimum of it using the same approach except for 2 changes"
    },
    {
      "index": 52,
      "start_time": 500400.0,
      "end_time": 507580.0,
      "text": "— we replace the first derivatives with a gradient and the second derivatives with a hessian."
    },
    {
      "index": 53,
      "start_time": 507580.0,
      "end_time": 516440.0,
      "text": "A hessian is a matrix of the second order partial derivatives of a scalar, and it describes the local curvature of a multivariable function."
    },
    {
      "index": 54,
      "start_time": 516440.00000000006,
      "end_time": 520080.00000000006,
      "text": "Derivatives help us compute gradients which we can represent using a Jacobian matrix for first order optimization."
    },
    {
      "index": 55,
      "start_time": 520080.00000000006,
      "end_time": 539680.0,
      "text": "And we use the hessian for second order optimization. These are 4 of the 5 derivative operators used in all of calculus, they’re the ways that we organize and represent change numerically."
    },
    {
      "index": 56,
      "start_time": 539680.0,
      "end_time": 552780.0,
      "text": "So when should you use a second order method?  First order methods are usually less computationally expensive to compute and less time expensive, converging pretty fast on large datasets."
    },
    {
      "index": 57,
      "start_time": 552780.0,
      "end_time": 558900.0,
      "text": "Second order methods are faster when the second derivative is known and easy to compute."
    },
    {
      "index": 58,
      "start_time": 558900.0,
      "end_time": 564740.0,
      "text": "But the second derivative is often intractable to compute, requiring lots of computation."
    },
    {
      "index": 59,
      "start_time": 564740.0,
      "end_time": 573920.0,
      "text": "For certain problems gradient descent can get stuck along paths of slow convergence around saddle points, whereas second order methods won’t."
    },
    {
      "index": 60,
      "start_time": 573920.0,
      "end_time": 582420.0,
      "text": "Trying out different optimization techniques for your specific problem is the best way to see what works best."
    },
    {
      "index": 61,
      "start_time": 582420.0,
      "end_time": 594180.0,
      "text": "Here are the key points to remember: First order optimization techniques use the first derivative of a function to minimize it, second order optimization techniques used"
    },
    {
      "index": 62,
      "start_time": 594180.0,
      "end_time": 604260.0,
      "text": "the second derivative. The Jacobian is a matrix of first partial derivatives and the Hessian is a matrix of second partial derivatives."
    },
    {
      "index": 63,
      "start_time": 604260.0,
      "end_time": 617060.0,
      "text": "And Newton’s Method is a a popular second order optimization technique that can sometimes outperform gradient descent. Last weeks coding challenge winner is Alberto Garces."
    },
    {
      "index": 64,
      "start_time": 617060.0,
      "end_time": 626400.0,
      "text": "Alberto used gradient descent to find the line of best fit His Jupyter notebook is insanely detailed, you could learn gradient descent just from reading it alone."
    },
    {
      "index": 65,
      "start_time": 626400.0,
      "end_time": 631940.0,
      "text": "Very well thought out. That was dope Alberto, Wizard of the Week."
    },
    {
      "index": 66,
      "start_time": 631940.0,
      "end_time": 637100.0,
      "text": "And the runner up is  Ivan Gusev who implemented gradient descent from scratch for polynomials of any order."
    },
    {
      "index": 67,
      "start_time": 637100.0,
      "end_time": 643460.0,
      "text": "This weeks challenge is to implement Newtons method for optimization from scratch. Details in the README,"
    },
    {
      "index": 68,
      "start_time": 643460.0,
      "end_time": 647320.0,
      "text": "post your GitHub link in the comments, winners announced next week."
    },
    {
      "index": 69,
      "start_time": 647320.0,
      "end_time": 653780.0,
      "text": "Please subscribe for more programming videos and for now I’ve gotta invent the 6th derivative so thanks for watching :)"
    }
  ]
}